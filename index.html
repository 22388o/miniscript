<!DOCTYPE html>
<html lang="en">
    <head>
        <!-- Required meta tags -->
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <title>Miniscript</title>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/css/bootstrap.min.css" integrity="sha384-rwoIResjU2yc3z8GV/NPeZWAv56rSmLldC3R/AZzGRnGxQQKnKkoFVhFQhNUwEyJ" crossorigin="anonymous">
        <!-- Optional theme -->
        <link rel="stylesheet" href="style.css">
        <style>
            .monospace {
                font-family: Consolas,Monaco,Lucida Console,Liberation Mono,DejaVu Sans Mono,Bitstream Vera Sans Mono,Courier New, monospace;
            }
            a.demo_link {
                text-decoration-style: dashed;
                text-underline-position: under;
            }
        </style>
    </head>
<body>
<script src="miniscript.js"></script>
<script>
em_miniscript_compile = Module.cwrap('miniscript_compile', 'none', ['string', 'number', 'number', 'number', 'number']);
em_miniscript_analyze = Module.cwrap('miniscript_analyze', 'none', ['string', 'number', 'number']);

function miniscript_compile() {
    document.getElementById("descout").value = "Compiling...";
    document.getElementById("spendout").innerHTML = "Compiling...";
    window.setTimeout(function() {
        src = document.getElementById("source").value;
        var descout = Module._malloc(1000);
        var spendout = Module._malloc(50000);
        em_miniscript_compile(src, descout, 1000, spendout, 50000);
        document.getElementById("descout").value = Module.UTF8ToString(descout);
        document.getElementById("spendout").innerHTML = Module.UTF8ToString(spendout);
        Module._free(descout)
        Module._free(spendout)
    });
}

function miniscript_analyze() {
    document.getElementById("spendout").innerHTML = "Analyzing...";
    window.setTimeout(function() {
        src = document.getElementById("descout").value;
        var spendout = Module._malloc(50000);
        em_miniscript_analyze(src, spendout, 50000);
        document.getElementById("spendout").innerHTML = Module.UTF8ToString(spendout);
        Module._free(spendout)
    });
}

</script>

<div class="container" style="margin-top:50px">

<div class="card mb-3 text-left">
<h3 class="card-header">Introduction</h3>
<div class="card-block">
<p>
<em>Miniscript</em> is a language for writing (a subset of) Bitcoin Scripts in a structured way, enabling analysis, composition, generic signing and more.
</p>

<p>
Bitcoin Script is an unusual stack-based language with many edge cases, designed for implementing spending conditions consisting of various combinations of
signatures, hash locks, and time locks. Yet despite being limited in functionality it is still highly nontrivial to:<ul>
<li>Given a combination of spending conditions, finding the most economical script to implement it.</li>
<li>Given a two scripts, construct a script that implements a composition of their spending conditions (e.g. a multisig where one of the "keys" is another multisig).</li>
<li>Given a script, find out what spending conditions it permits.</li>
<li>Given a script and access to a sufficient set of private keys, construct a general satisfying witness for it.</li>
<li>Given a script, be able to predict the cost of spending an output.</li>
<li>Given a script, know whether any code path requires violating particular resource limitations like the ops limit.</li>
</ul>
</p>

<p>
Miniscript functions as a representation for scripts that makes these sort of operations possible. It has a structure that allows composition. It is very easy to 
statically analyze for various properties (spending conditions, correctness, security properties, malleability, ...). It can be targeted by spending policy compilers
(see further). Finally, compatible scripts easily can be converted to miniscript - avoiding the need for additional metadata for e.g. signing devices that support it.
</p>

<p>
For now, Miniscript is really only designed for P2WSH and P2SH-P2WSH embedded scripts. Most of its constructions works fine in P2SH as well, but some of the (optional) security properties
rely on Segwit-specific rules. Furthermore, the implemented policy compilers assume a Segwit-specific cost model.
</p>
</div>
</div>

<div class="card mb-3 text-left">
<h3 class="card-header">Miniscript reference</h3>
<div class="card-block">
<h4>Translation table</h4>
<p>
This table shows all Miniscript <em>fragments</em> and their associated semantics and Bitcoin Script.
Fragments that do not change the semantics of their subexpressions are called <em>wrappers</em>. Normal fragments use
a "fragment(arguments,...)" notation, while wrappers are written using prefixes separated from other fragments
by a colon. The colon is dropped between subsequent wrappers; e.g. <code>vc:pk(key)</code> is the <code>v:</code>
wrapper applied to the <code>c:</code> wrapper applied to the <code>pk</code> fragment for a given key.

<table class="table table-sm">
<thead class="thead-light">
<tr><th scope="col">Semantics</th><th scope="col">Miniscript fragment</th><th scope="col">Bitcoin Script</th></tr></thead>
<tbody>
<tr>
  <td>false</td>
  <td><code>0</code></td>
  <td><samp>0</samp></td>
</tr>
<tr>
  <td>true</td>
  <td><code>1</code></td>
  <td><samp>1</samp></td>
</tr>
<tr>
  <td rowspan="2">check(key)</td>
  <td><code>pk(key)</code></td>
  <td><samp>&lt;key&gt;</samp></td>
</tr>
<tr>
  <td><code>pk_h(key)</code></td>
  <td><samp>DUP HASH160 &lt;HASH160(key)&gt; EQUALVERFIFY</samp></td>
</tr>
<tr>
  <td>nSequence &ge; n (and compatible)</td>
  <td><code>older(n)</code></td>
  <td><samp>&lt;n&gt; CHECKSEQUENCEVERIFY</samp></td>
</tr>
<tr>
  <td>nLockTime &ge; n (and compaitlbe)</td>
  <td><code>after(n)</code></td>
  <td><samp>&lt;n&gt; CHECKLOCKTIMEVERIFY</samp></td>
</tr>
<tr>
  <td>len(x) = 32 and SHA256(x) = h</td>
  <td><code>sha256(h)</code></td>
  <td><samp>SIZE &lt;32&gt; EQUALVERIFY SHA256 &lt;h&gt; EQUAL</samp></td>
</tr>
<tr>
  <td>len(x) = 32 and HASH256(x) = h</td>
  <td><code>hash256(h)</code></td>
  <td><samp>SIZE &lt;32&gt; EQUALVERIFY HASH256 &lt;h&gt; EQUAL</samp></td>
</tr>
<tr>
  <td>len(x) = 32 and RIPEMD160(x) = h</td>
  <td><code>ripemd160(h)</code></td>
  <td><samp>SIZE &lt;32&gt; EQUALVERIFY RIPEMD160 &lt;h&gt; EQUAL</samp></td>
</tr>
<tr>
  <td>len(x) = 32 and HASH160(x) = h</td>
  <td><code>hash160(h)</code></td>
  <td><samp>SIZE &lt;32&gt; EQUALVERIFY HASH160 &lt;h&gt; EQUAL</samp></td>
<tr>
  <td>(<em>X</em> and <em>Y</em>) or <em>Z</em></td>
  <td><code>andor(<em>X</em>,<em>Y</em>,<em>Z</em>)</code></td>
  <td><samp><em>[X]</em> NOTIF <em>[Z]</em> ELSE <em>[Y]</em> ENDIF</samp></td>
</tr>
<tr>
  <td rowspan="3"><em>X</em> and <em>Y</em></td>
  <td><code>and_v(<em>X</em>,<em>Y</em>)</code></td>
  <td><samp><em>[X]</em> <em>[Y]</em></samp></td>
</tr>
<tr>
  <td><code>and_b(<em>X</em>,<em>Y</em>)</code></td>
  <td><samp><em>[X]</em> <em>[Y]</em> BOOLAND</samp></td>
</tr>
<tr>
  <td><code>and_n(<em>X</em>,<em>Y</em>)</code> = <code>andor(<em>X</em>,<em>Y</em>,0)</code></td>
  <td><samp><em>[X]</em> NOTIF 0 ELSE <em>[Y]</em> ENDIF</samp></td>
</tr>
<tr>
  <td rowspan="4"><em>X</em> or <em>Z</em></td>
  <td><code>or_b(<em>X</em>,<em>Z</em>)</code></td>
  <td><samp><em>[X]</em> <em>[Z]</em> BOOLOR</samp></td>
</tr>
<tr>
  <td><code>or_c(<em>X</em>,<em>Z</em>)</code></td>
  <td><samp><em>[X]</em> NOTIF <em>[Z]</em> ENDIF</samp></td>
</tr>
<tr>
  <td><code>or_d(<em>X</em>,<em>Z</em>)</code></td>
  <td><samp><em>[X]</em> IFDUP NOTIF <em>[Z]</em> ENDIF</samp></td>
</tr>
<tr>
  <td><code>or_i(<em>X</em>,<em>Z</em>)</code></td>
  <td><samp>IF <em>[X]</em> ELSE <em>[Z]</em> ENDIF</samp></td>
</tr>
<tr>
  <td><em>X<sub>1</sub></em> + ... + <em>X<sub>n</sub></em> = k</td>
  <td><code>thresh(k,<em>X<sub>1</sub></em>,...,<em>X<sub>n</sub></em>)</code></td>
  <td><samp><em>[X<sub>1</sub>]</em> <em>[X<sub>2</sub>]</em> ADD ... <em>[X<sub>n</sub>]</em> ADD ... &lt;k&gt; EQUAL</samp></td>
</tr>
<tr>
  <td>check(key<sub>1</sub>) + ... + check(key<sub>n</sub>) = k</td>
  <td><code>thresh_m(k,key<sub>1</sub>,...,key<sub>n</sub>)</code></td>
  <td><samp>&lt;k&gt; &lt;key<sub>1</sub>&gt; ... &lt;key<sub>n</sub>&gt; &lt;n&gt; CHECKMULTISIG</samp></td>
</tr>
<tr>
  <td rowspan="10"><em>X</em> (identities)</td>
  <td><code>a:<em>X</em></code></td>
  <td><samp>TOALTSTACK <em>[X]</em> FROMALTSTACK</samp></td>
</tr>
<tr>
  <td><code>s:<em>X</em></code></td>
  <td><samp>SWAP <em>[X]</em></samp></td>
</tr>
<tr>
  <td><code>c:<em>X</em></code></td>
  <td><samp><em>[X]</em> CHECKSIG</samp></td>
</tr>
<tr>
  <td><code>t:<em>X</em></code> = <code>and_v(<em>X</em>,1)</code></td>
  <td><samp><em>[X]</em> 1</samp></td>
<tr>
  <td><code>d:<em>X</em></code></td>
  <td><samp>DUP IF <em>[X]</em> ENDIF</samp></td>
</tr>
<tr>
  <td><code>v:<em>X</em></code></td>
  <td><samp><em>[X]</em> VERIFY</samp> (or <samp>VERIFY</samp> version of last opcode in <samp><em>[X]</em></samp>)</td>
</tr>
<tr>
  <td><code>j:<em>X</em></code></td>
  <td><samp>SIZE 0NOTEQUAL IF <em>[X]</em> ENDIF</samp></td>
</tr>
<tr>
  <td><code>n:<em>X</em></code></td>
  <td><samp><em>[X]</em> 0NOTEQUAL</samp></td>
</tr>
<tr>
  <td><code>l:<em>X</em></code> = <code>or_i(0,<em>X</em>)</code></td>
  <td><samp>IF 0 ELSE <em>[X]</em> ENDIF</samp></td>
</tr>
<tr>
  <td><code>u:<em>X</em></code> = <code>or_i(<em>X</em>,0)</code></td>
  <td><samp>IF <em>[X]</em> ELSE 0 ENDIF</samp></td>
</tr>
</tbody>
</table>
The <code>and_n</code> fragment and <code>t:</code>, <code>l:</code>, and <code>u:</code> wrappers are syntactic sugar for other Miniscripts, as listed in the table above.
In what follows, they will not be included anymore, as their properties can be derived by looking at their expansion.
</p>

<h4>Correctness properties</h4>

<p>
Not every Miniscript expression can be composed with every other. Some return their result by putting zero or false on the stack; others distinguish by aborting or continuing.
Some require subexpressions that consume an exactly known number of arguments, while others need a subexpression that has a nonzero top stack element to satisfy. To model all
these properties, we define a correctness type system for Miniscript.
</p>

<p>
Every miniscript expression has one of four basic types:<ul>
<li><b>"B"</b> Base expressions:<ul>
  <li>Takes its inputs from the top of the stack.</li>
  <li>When satisfied, pushes a nonzero value of up to 4 bytes onto the stack.</li>
  <li>When dissatisfied, pushes a 0 onto the stack.</li>
  <li>This is used for most expressions, and required for the top level one.</li>
  <li>For example: <code>older(n)</code> = <samp>&lt;n&gt; CHECKSEQUENCEVERIFY</samp>.</li>
</ul></li>
<li><b>"V"</b> Verify expressions:<ul>
  <li>Takes its inputs from the top of the stack.</li>
  <li>When satisfactied, pushes nothing.</li>
  <li>Cannot be dissatisfied (aborts execution instead).</li>
  <li>A "V" can be obtained using the <code>v:</code> wrapper on a "B" expression, or by combining other "V" expressions using <code>and_v</code>, <code>or_i</code>, <code>or_c</code>, or <code>andor</code>.</li>
  <li>For example <code>vc:pk(key)</code> = <samp>&lt;key&gt; CHECKSIGVERIFY</samp>.</li>
</ul></li>
<li><b>"K"</b> Key expressions:<ul>
  <li>Takes its inputs from the top of the stack.</li>
  <li>Always pushes a public key onto the stack, for which a signature is to be provided to satisfy the expression.</li>
  <li>Can be converted into a "B" using the <code>c:</code> wrapper (<samp>CHECKSIG</samp>).</li>
  <li>For example <code>pk_h(key)</code> = <samp>DUP HASH160 &lt;Hash160(key)&gt; EQUALVERIFY</samp></li>
</ul></li>
<li><b>"W"</b> Wrapped expressions:<ul>
  <li>Takes its input from one below the top of the stack.</li>
  <li>When satisfied, pushes a nonzero value (like B) on top of the stack, or one below the top.</li>
  <li>When dissatisfied, pushes 0 op top of the stack or one below the top.</li>
  <li>Every "W" is either <code>s:B</code> (<samp>SWAP B</samp>) or <code>a:B</code> (<samp>TOALTSTACK B FROMALTSTACK</code>).</li>
  <li>For example <code>sc:pk(key)</code> = <samp>SWAP &lt;key&gt; CHECKSIG</samp>.</li>
</ul></li>
</ul>
</p>

<p>
Then there are 5 type modifiers, which guarantee additional properties:<ul>
<li><b>"z"</b> Zero-arg: this expression always consumes exactly 0 stack elements.</li>
<li><b>"o"</b> One-arg: this expression always consumes exactly 1 stack element.</li>
<li><b>"n"</b> Nonzero: no satisfaction for this expression requires a top stack element that is zero.</li>
<li><b>"d"</b> Dissatisfiable: a canonical dissatisfaction exists for this expression that can be constructed by anyone.</li>
<li><b>"u"</b> Unit: when satisfied, this expression will put an exact 1 on the stack (as opposed to any nonzero value).</li>
</ul>
</p>

<p>
This tables lists the correctness requirements for each of the Miniscript expressions, and its type properties in function of those of their subexpressions:
<table class="table table-sm">
<thead class="thead-light"><tr><th scope="col">Miniscript</th><th scope="col">Requires</th><th scope="col">Type</th><th scope="col">Properties</th></tr></thead>
<tbody>
<tr><td><code>0</code></td><td></td><td>B</td><td>z; u; d</td></tr>
<tr><td><code>1</code></td><td></td><td>B</td><td>z; u</td></tr>
<tr><td><code>pk(key)</code></td><td></td><td>K</td><td>o; n; d; u</td></tr>
<tr><td><code>pk_h(key)</code></td><td></td><td>K</td><td>n; d; u</td></tr>
<tr><td><code>older(n)</code>, <code>after(n)</code></td><td>1 &le; n &lt; 2<sup>31</sup></td><td>B</td><td>z</td></tr>
<tr><td><code>sha256(h)</code></td><td></td><td>B</td><td>o; n; d; u</td></tr>
<tr><td><code>ripemd160(h)</code></td><td></td><td>B</td><td>o; n; d; u</td></tr>
<tr><td><code>hash256(h)</code></td><td></td><td>B</td><td>o; n; d; u</td></tr>
<tr><td><code>hash160(h)</code></td><td></td><td>B</td><td>o; n; d; u</td></tr>
<tr><td><code>andor(<em>X</em>,<em>Y</em>,<em>Z</em>)</code></td><td><em>X</em> is Bdu; <em>Y</em> and <em>Z</em> are both B, K, or V</td><td>same as Y/Z</td><td>z=z<sub>X</sub>z<sub>Y</sub>z<sub>Z</sub>; o=z<sub>X</sub>o<sub>Y</sub>o<sub>Z</sub> or o<sub>X</sub>z<sub>Y</sub>z<sub>Z</sub>; u=u<sub>Y</sub>u<sub>Z</sub>; d=d<sub>Z</sub></td></tr>
<tr><td><code>and_v(<em>X</em>,<em>Y</em>)</code></td><td><em>X</em> is V; <em>Y</em> is B, K, or V</td><td>same as <em>Y</em></td><td>z=z<sub>X</sub>z<sub>Y</sub>; o=z<sub>X</sub>o<sub>Y</sub> or z<sub>Y</sub>o<sub>X</sub>; n=n<sub>X</sub> or z<sub>X</sub>n<sub>Y</sub>; u=u<sub>Y</sub></td></tr>
<tr><td><code>and_b(<em>X</em>,<em>Y</em>)</code></td><td><em>X</em> is B; <em>Y</em> is W</td><td>B</td><td>z=z<sub>X</sub>z<sub>Y</sub>; o=z<sub>X</sub>o<sub>Y</sub> or z<sub>Y</sub>o<sub>X</sub>; n=n<sub>X</sub> or z<sub>X</sub>n<sub>Y</sub>; d=d<sub>X</sub>d<sub>Y</sub>; u</td></tr>
<tr><td><code>or_b(<em>X</em>,<em>Z</em>)</code></td><td><em>X</em> is Bd; <em>Z</em> is Wd</td><td>B</td><td>z=z<sub>X</sub>z<sub>Z</sub>; o=z<sub>X</sub>o<sub>Y</sub> or z<sub>Y</sub>o<sub>X</sub>; d; u</td></tr>
<tr><td><code>or_c(<em>X</em>,<em>Z</em>)</code></td><td><em>X</em> is Bdu; <em>Z</em> is V</td><td>V</td><td>z=z<sub>X</sub>z<sub>Z</sub>; o=o<sub>X</sub>z<sub>Z</sub></td></tr>
<tr><td><code>or_d(<em>X</em>,<em>Z</em>)</code></td><td><em>X</em> is Bdu; <em>Z</em> is B</td><td>B</td><td>z=z<sub>X</sub>z<sub>Z</sub>; o=o<sub>X</sub>z<sub>Z</sub>; d=d<sub>Z</sub>; u=u<sub>Z</sub></td></tr>
<tr><td><code>or_i(<em>X</em>,<em>Z</em>)</code></td><td>both are B, K, or V</td><td>same as X/Z</td><td>o=z<sub>X</sub>z<sub>Z</sub>; u=u<sub>X</sub>u<sub>Z</sub>; d=d<sub>X</sub> or d<sub>Z</sub></td></tr>
<tr><td><code>thresh(k,<em>X<sub>1</sub><em>,...,<em>X<sub>n</sub></em>)</code></td><td>1 &lt; k &lt; n; <em>X<sub>1</sub></em> is Bdu; others are Wdu</td><td>B</td><td>z=all are z; o=all are z except one is o; d; u</td></tr>
<tr><td><code>thresh_m(k,key<sub>1</sub>,...,key<sub>n</sub>)</code></td><td>1 &le; k &le; n</td><td>B</td><td>n; d; u</td></tr>
<tr><td><code>a:X</code></td><td><em>X</em> is B</td><td>W</td><td>d=d<sub>X</sub>; u=u<sub>X</sub></td></tr>
<tr><td><code>s:X</code></td><td><em>X</em> is Bo</td><td>W</td><td>d=d<sub>X</sub>; u=u<sub>X</sub></td></tr>
<tr><td><code>c:X</code></td><td><em>X</em> is K</td><td>B</td><td>o=o<sub>X</sub>; n=n<sub>X</sub>; d=d<sub>X</sub>; u</td></tr>
<tr><td><code>d:X</code></td><td><em>X</em> is Vz</td><td>B</td><td>o=z<sub>X</sub>; n; u; d</td></tr>
<tr><td><code>v:X</code></td><td><em>X</em> is B</td><td>V</td><td>z=z<sub>X</sub>; o=o<sub>X</sub>; n=n<sub>X</sub></td></tr>
<tr><td><code>j:X</code></td><td><em>X</em> is Bn</td><td>B</td><td>o=o<sub>X</sub>; n; d; u=u<sub>X</sub></td></tr>
<tr><td><code>n:X</code></td><td><em>X</em> is B</td><td>B</td><td>z=z<sub>X</sub>; o=o<sub>X</sub>; n=n<sub>X</sub>; d=d<sub>X</sub>; u</td></tr>
</tbody>
</table>
</p>

<h4>Resource limitations</h4>

<p>
Various types of Bitcoin Scripts have different resource limitations, either through consensus or standardness. Some of them affect otherwise valid Miniscripts: <ul>
<li>Scripts over 10000 bytes are invalid by consensus (bare, P2SH, P2WSH, P2SH-P2WSH).</li>
<li>Scripts over 520 bytes are invalid by consensus (P2SH).</li>
<li>Script satisfactions where the total number of non-push opcodes plus the number of keys participating in all executed <code>thresh_m</code>s, is above 201, are invalid by consensus (bare, P2SH, P2WSH, P2SH-P2WSH).</li>
<li>Anything but <code>c:pk(key)</code> (P2PK), <code>c:pk_h(key)</code> (P2PKH), and <code>thresh_m(k,...)</code> up to n=3 is invalid by standardness (bare).</li>
<li>Scripts over 3600 bytes are invalid by standardness (P2WSH, P2SH-P2WSH).</li>
<li>Script satisfactions with a serialized <samp>scriptSig</samp> over 1650 bytes are invalid by standardness (P2SH).</li>
<li>Script satisfactions with a witness consisting of over 100 stack elements (excluding the script itself) are invalid by standardness (P2WSH, P2SH-P2WSH).</li>
</ul>
Miniscript makes it easy to verify these properties statically for all possible execution paths.
</p>

<h4>Security properties</h4>
<p>
The type system above guarantees that the corresponding Bitcoin Scripts are:<ul>
  <li><b>consensus and standardness complete</b>: Assuming the resource limits listed in the previous section are not violated, for every way that the spending conditions associated with the Miniscript can be met, a witness can be constructed that passes Bitcoin's consensus rules and common standardness rules.</li>
  <li><b>consensus sound</b>: It is not possible to construct a witness that is consensus valid for a Script unless the spending conditions are met. Since standardness rules permit only a subset of consensus-valid satisfactions (by definition), this property also implies <b>standardness soundness</b>.
</ul>
</p>

<p>
The completeness property has been extensively tested for P2WSH by verifying large numbers of random satisfactions for random Miniscript expressions against Bitcoin Core's consensus and standardness implementation.
<p>

<p>In order for these properties to not just apply to script, but to an entire transaction, it's important that the witness commits to all data relevant for verification. In practice
this means that scripts whose conditions can be met without any digital signature are insecure. For example, if an output can be spent by simply passing a certain <samp>nLockTime</samp>
(an <code>after(n)</code> fragment in Miniscript) but without any digital signatures, an attacker can modify the <samp>nLockTime</samp> field in the spending transaction.
</p>
</div>
</div>

<div class="card mb-3 text-left">
<h3 class="card-header">Satisfactions and malleability</h3>
<div class="card-block">
<h4>Basic satisfactions</h4>
<p>
The following table shows all valid satisfactions and dissatisfactions for every Miniscript, using satisfactions and dissatisfactions of its subexpressions.
Multiple possibilities are separated by semicolons. Some options are not actually necessary to produce correct witnesses, and are called <em>non-canonical</em> options. They
are listed for completeness, but marked in <span class="text-muted">[grey]</span> below.
<table class="table table-sm">
<thead class="thead-light"><tr><th scope="col">Miniscript</th><th scope="col">Dissatisfactions (dsat)</th><th scope="col">Satisfactions (sat)</th></thead>
<tbody>
<tr><td><code>0</code></td><td></td><td>-</td></tr>
<tr><td><code>1</code></td><td>-</td><td></td></tr>
<tr><td><code>pk(key)</code></td><td>0</td><td>sig</td></tr>
<tr><td><code>pk_h(key)</code></td><td>0</td><td>sig key</td></tr>
<tr><td><code>older(n)</code></td><td>-</td><td></td></tr>
<tr><td><code>after(n)</code></td><td>-</td><td></td></tr>
<tr><td><code>sha256(h)</code></td><td>any 32-byte vector except the preimage</td><td>preimage</td></tr>
<tr><td><code>ripemd160(h)</code></td><td>any 32-byte vector except the preimage</td><td>preimage</td></tr>
<tr><td><code>hash256(h)</code></td><td>any 32-byte vector except the preimage</td><td>preimage</td></tr>
<tr><td><code>hash160(h)</code></td><td>any 32-byte vector except the preimage</td><td>preimage</td></tr>
<tr><td><code>andor(<em>X</em>,<em>Y</em>,<em>Z</em>)</code></td><td>dsat(<em>Z</em>) dsat(<em>X</em>); <span class="text-muted">[dsat(<em>Y</em>) sat(<em>X</em>)]</span></td><td>sat(<em>Y</em>) sat(<em>X</em>); sat(<em>Z</em>) dsat(<em>X</em>)</td></tr>
<tr><td><code>and_v(<em>X</em>,<em>Y</em>)</code></td><td>-</td><td>sat(<em>Y</em>) sat(<em>X</em>)</td></tr>
<tr><td><code>and_b(<em>X</em>,<em>Y</em>)</code></td><td>dsat(<em>Y</em>) dsat(<em>X</em>); <span class="text-muted">[sat(<em>Y</em>) dsat(<em>X</em>)]</span>; <span class="text-muted">[dsat(<em>Y</em>) sat(<em>X</em>)]</span></td><td>sat(<em>Y</em>) sat(<em>X</em>)</td></tr>
<tr><td><code>or_b(<em>X</em>,<em>Z</em>)</code></td><td>dsat(<em>Z</em>) dsat(<em>X</em>)</td><td>dsat(<em>Z</em>) sat(<em>X</em>); sat(<em>Z</em>) dsat(<em>X</em>); <span class="text-muted">[sat(<em>Z</em>) sat(<em>X</em>)]</span></td></tr>
<tr><td><code>or_c(<em>X</em>,<em>Z</em>)</code></td><td>-</td><td>sat(<em>X</em>); sat(<em>Z</em>) dsat(<em>X</em>)</td></tr>
<tr><td><code>or_d(<em>X</em>,<em>Z</em>)</code></td><td>dsat(<em>Z</em>) dsat(<em>X</em>)</td><td>sat(<em>X</em>); sat(<em>Z</em>) dsat(<em>X</em>)</td></tr>
<tr><td><code>or_i(<em>X</em>,<em>Z</em>)</code></td><td>dsat(<em>X</em>) 1; dsat(<em>Z</em>) 0</td><td>sat(<em>X</em>) 1; sat(<em>Z</em>) 0</td></tr>
<tr><td><code>thresh(k,<em>X<sub>1</sub></em>,...,<em>X<sub>n</sub></em>)</code></td><td>All dsats <span class="text-muted">[Sats/dsats with 1 &le; #(sats) &ne; k]</span></td><td>Sats/dsats with #(sats) = k</td></tr>
<tr><td><code>thresh_m(k,key<sub>1</sub>,...,key<sub>n</sub>)</code></td><td>0 0 ... 0 (n+1 times)</td><td>0 sig ... sig</td></tr>
<tr><td><code>a:<em>X</em></code></td><td>dsat(<em>X</em>)</td><td>sat(<em>X</em>)</td></tr>
<tr><td><code>s:<em>X</em></code></td><td>dsat(<em>X</em>)</td><td>sat(<em>X</em>)</td></tr>
<tr><td><code>c:<em>X</em></code></td><td>dsat(<em>X</em>)</td><td>sat(<em>X</em>)</td></tr>
<tr><td><code>d:<em>X</em></code></td><td>0</td><td>sat(<em>X</em>) 1</td></tr>
<tr><td><code>v:<em>X</em></code></td><td>-</td><td>sat(<em>X</em>)</td></tr>
<tr><td><code>j:<em>X</em></code></td><td>0; <span class="text-muted">[nsat(<em>X</em>) (if nonzero top stack)]</span></td><td>sat(<em>X</em>)</td></tr>
<tr><td><code>n:<em>X</em></code></td><td>dsat(<em>X</em>)</td><td>sat(<em>X</em>)</td></tr>
</tbody>
</table>
</p>
<p>
The correctness properties in the previous section are based on the availability of satisfactions and dissatisfactions listed above. The requirements include a "d" for every
subexpression whose dissatisfaction may be needed in building a satisfaction for the parent expression. The "d" properties themselves rely on the "d" properties of subexpressions.
</p>

<p>
A conservative simplification is made here, ignoring the existence of always-true expressions like <code>1</code>. This makes the typing rules incorrect in the following cases:<ul>
<li><code>or_b(<em>X</em>,1)</code> and <code>or_b(1,<em>X</em>)</code> are complete when <em>X</em> is. In that case, the condition is equivalent to 1 and is always met, and a satisfaction of the form "nsat(<em>X</em>)" exists.
<li><code>or_b(1,1)</code> is complete, as it is equivalent to 1 and "" is a valid satisfaction.</li>
<li><code>and_b(<em>X</em>,1)</code> and <code>and_b(1,<em>X</em>)</code> are dissatisfiable ("d") when <em>X</em> is.
<li><code>andor(1,1,<em>Z</em>)</code> is complete, as it is equivalent to 1 and "" is a valid satisfaction.</li>
<li><code>andor(1,<em>Y</em>,0)</code> is complete when <em>Y</em> is; it also has the same type as <em>Y</em>, despite <code>0</code> always being a "B". This is also dissatisfiable when <em>Y</em> is.
<li>The <code>1</code>s items listed above can be replaced with any other always-true expression.
</ul>
Since all these cases of simplified typing involve always-true expressions that can be avoided
using strictly cheaper Miniscripts, we don't consider this to be a serious restriction.
</p>

<h4>Malleability</h4>
<p>
While following the table above to construct satisfactions is sufficient for meeting the completeness and soundness properties, it does not guarantee non-malleability.
</p>

<p>
Malleability is the ability for a third party (<em>not</em> a participant in the script) to modify an existing satisfaction into another valid satisfaction.
Since Segwit, malleating a transaction no longer breaks the validity of unconfirmed descendant transactions. However, unintentional malleability may still have a number of
much weaker undesirable effects. If a witness can be stuffed with additional data, the transaction's feerate will go down, potentially to the point where its ability to
propagate and get confirmed is impacted. Additionally, malleability can be exploited to add roundtrips to BIP152 block propagation, by trying to get different miners to mine different versions
of the same transaction. Finally, malleability may interfere with the usage of hash locks as a mechanism for publishing preimages.
</p>

<p>
Because of these reasons, Miniscript is actually designed to permit non-malleable signing. As this guarantee is restricted in non-obvious ways, let's first state the assumptions:<ul>
<li>The attacker does not have access to any of the private keys of public keys that participate in the Script. Limiting the impact a rogue participant can have is a distinct attack model.</li>
<li>The attacker only has access to hash preimages that honest users have access to as well.</li>
<li>The attacker gets to see exactly one satisfying witness of the script. If he sees multiple, the protections defined here are not necessarily valid anymore.</li>
</ul>
</p>

<p>
Malleable satisfactions or dissatisfactions appear whenever options are available to attackers distinct from the one taken by honest users. This can happen for multiple reasons:<ul>
<li>Two or more options for a satisfaction or dissatisfaction are listed in the table above which are both available to attackers directly. Regardless of which option is used in the honest solution, the attacker can change the solution to the other one.</li>
<li>Two ore more options for a satisfaction or dissatisfaction are listed in the table above, only one of which is available to attackers, but the honest solution uses another one. In that case, the attacker can modify the solution to pick the one available to him.</li>
<li>The honest users pick a solution that contains a satisfaction which can be turned into a dissatisfaction without invalidating the overall witness. Those are called an overcomplete solutions.</li>
</ul>
</p>

<h4>Non-malleable satisfaction algorithm</h4>

<p>
Because we assume attackers never have access to private keys, we can treat any solution that includes a signature as one that is unavailable to attackers.
For others, the worst case is that the attacker has access to every solution the honest users have, but no others: for preimages this is an explicit assumption, while timelock availability is determined
by the <samp>nLockTime</samp> and <samp>nSequence</samp> fields in the transaction. As long as the overall satisfaction includes at least one signature, those values are fixed, and timelock availability is identical for attackers and honest users.
</p>

<p>
In order to produce non-malleable satisfactions we make use of a function that returns the optimal satisfaction and dissatisfaction for a given expression (if any exist), or a special DONTUSE value, together with an optional HASSIG marker that tracks whether the solution contains at least one signature. To implement the function: <ul>
<li>Invoke the function recursively for all subexpressions, obtaining all satisfactions/dissatisfactions for those.</li>
<li>Iterate over all the valid satisfactions/dissatisfactions in the table above (including the non-canonical ones), taking into account:<ul>
  <li>The dissatisfactions for <code>sha256</code>, <code>ripemd160</code>, <code>hash256</code>, and <code>hash160</code> are always malleable, so instead use DONTUSE there.</li>
  <li>The non-canonical options for <code>and_b</code>, <code>or_b</code>, and <code>thresh</code> are always overcomplete, so instead use DONTUSE there as well (with HASSIG flag if the original non-canonical solution had one).
  <li>The satisfactions for <code>pk</code>, <code>pk_h</code>, and <code>thresh_m</code> can be marked HASSIG.</li>
  <li>When constructing solutions by combining results for subexpressions, the result is DONTUSE if any of the constituent results is DONTUSE. Furthermore, the result gets the HASSIG tag if any of the constituents do.</li>
</ul></li>
<li>If among all valid solutions (including DONTUSE ones) more than one does not have the HASSIG marker, return DONTUSE, as this means there are multiple options for the attacker, so whatever we pick, the attacker could change it to the other option.</li>
<li>If instead exactly one does not have the HASSIG marker, return that solution. It means there is exactly one option available to the attacker, so we have to pick it to prevent him from changing another solution to this one.</li>
<li>If all valid solutions have the HASSIG marker, but all of them are DONTUSE, return DONTUSE-HASSIG. The HASSIG marker is important because while this represents a choice between multiple options that would cause malleability if used, they are not available to the attacker, and we may be able to avoid them entirely still.
<li>Otherwise, return the smallest solution (in terms of witness size) among the not-DONTUSE ones.
</ul>
To produce an overall satisfaction, invoke the function on the toplevel expression. If no valid satisfaction is returned, or it is DONTUSE, fail. Otherwise, if any timelocking is used in the script but the result does not have the HASSIG flag, also fail, as this represents a situation where an attacker could change the <samp>nLockTime</samp> or <samp>nSequence</samp> values to meet additional timelock conditions. Not to mention that solutions without signatures are generally insecure. If the satisfaction is both not DONTUSE and HASSIG, return it.
</p>

<p>
The above can be used to show that no non-canonical solutions listed in the satisfaction table can occur inside non-malleable satisfactions.<ul>
<li>The <code>or_b(<em>X</em>,<em>Z</em>)</code> non-canonical satisfaction is overcomplete, and thus can clearly not appear in non-malleable satisfactions.</li>
<li>It can be shown that non-"d" expressions cannot be dissatisfied in valid witnesses, as for those, dissatisfaction implies aborting or propagating failure upwards, ultimately dissatisfying the top-level expression.</li>
<li>"d" expressions are by the type system guaranteed to be dissatisfiable using dissatisfactions of its subexpressions which are themselves "d".
    Since no dissatisfactions ever directly include a signature, every "d" expression must have a non-HASSIG dissatisfaction. Non-HASSIG solutions
    are preferred over HASSIG ones, and when multiple non-HASSIG ones exist, none can be used. This is the case for the other non-canonical options in the table:<ul>
        <li>If <code>andor(<em>X</em>,<em>Y</em>,<em>Z</em>)</code> is "d", a non-HASSIG dissatisfaction "dsat(<em>Z</em>) dsat(<em>X</em>)" must exist, and thus rules out any usage of "dsat(<em>Y</em>) sat(<em>X</em>)".</li>
        <li><code>j:X</code> is always "d", its non-HASSIG dissatisfaction "0" always exists, and thus rules out any usage of "dsat(<em>X</em>)".
        <li>If <code>and_b(<em>X</em>,<em>Y</em>)</code> is "d", a non-HASSIG dissatisfaction "dsat(<em>Y</em>) dsat(<em>X</em>)" must exist, and thus rules out any usage of "dsat(<em>Y</em>) sat(<em>X</em>)" and "sat(<em>Y</em>) dsat(<em>X</em>)". Those are also overcomplete. </li>
        <li><code>thresh(k,...)</code> is always "d", a non-HASSIG dissatisfaction with just dissatisfactions must exist due to typing rules, and thus rules out usage of the other dissatisfactions. They are also overcomplete.</li>
    </ul>
</ul>
</p>

</div>
</div>

<div class="card mb-3 text-left">
<h3 class="card-header">Compiler demo</h3>
<div class="card-block">

<textarea rows="1" cols="100" id="source">
and(pk(C),or(pk(C),or(9@pk(C),older(1000))))
</textarea><br/>
<button type="button" onclick="miniscript_compile();">Compile</button>
Supported elements:
<ul>
<li><b>pk(HEX)</b>: Require public key HEX to sign.</li>
<li><b>time(NUMBER)</b>: Require that a relative time NUMBER has passed since creating the output.</li>
<li><b>hash(HEX)</b>: Require that the SHA256 preimage of HEX is revealed.</li>
<li><b>and(EXPR,EXPR)</b>: Require that both subexpressions are satisfied.</li>
<li><b>or([N@]EXPR,[N@]EXPR)</b>: Require that one of the subexpressions is satisfied. The numbers N indicate the relative probability of each of the subexpressions.</li>
<li><b>thresh(NUM,EXPR,EXPR,...)</b>: Require that NUM out of the following subexpressions are satisfied.</li>
</ul>
Shorthands:
<ul>
<li><b>C</b>: A dummy compressed public key (usable as argument to pk or multi)</li>
<li><b>U</b>: A dummy uncompressed public key (usable as argument to pk or multi)</li>
<li><b>H</b>: A dummy hash (usable as argument to hash)</li>
</ul>

<hr/>
<b>Miniscript output</b><br/>
<textarea rows="4" cols="100" id="descout"></textarea>
<button type="button" onclick="miniscript_analyze();">Analyze</button>

<hr/>
<b>Analysis</b><br/>
<a id="spendout"></a>
</div>
</div>


<div class="card text-left">
<h3 class="card-header">Miniscript reference</h3>
<div class="card-block">

<table border="1">
<tr><th>Type</th><th>Shorthand</th><th>Behavior under honest inputs</th><th>Behavior under adverserial inputs</th></tr>
<tr><td>Base</td><td>B</td><td>Takes its inputs from the top of the stack. Pushes a nonzero value of up to 4 bytes if the condition is satisfied, exactly zero otherwise.</td><td>Pushes zero onto the stack, or aborts.</td></tr>
<tr><td>Key</td><td>K</td><td>Takes its inputs from the top of the stack. Pushes a public key with which a checksig is to be done onto the stack.</td><td>Aborts.</td></tr>
<tr><td>Verify</td><td>V</td><td>Takes its inputs from the top of the stack, which must satisfy the condition. Does not push anything onto the stack.</td><td>Aborts.</td></tr>
<tr><td>Wrapped</td><td>W</td><td>Takes from the stack its inputs + element X at the top. If the inputs satisfy the condition, [t X] or [X t] is pushed, where t is a nonzero value of up to 4 bytes. If not, [0 X] or [X 0] is pushed.</td><td>Pushes [0 X] or [X 0] onto the stack, or aborts.</td></tr>
</table>

In addition, every expression can have zero or more of the following properties used for reasoning about correctness:<ul>
<li><b>z</b> "zero": Known to consume exactly zero stack elements. Conflicts with "o".</li>
<li><b>o</b> "one": Known to consume exactly one stack element. Conflicts with "z".</li>
<li><b>n</b> "nonzero": Known to consume at least one stack element, and the top element is never required to be 0 to satisfy the condition. Conflicts with "z". Impossible for W.</li>
<li><b>d</b> "dissatisfiable": There is a guaranteed way to this dissatisfy the expression. Impossible for V.</li>
<li><b>u</b> "unit": Satisfaction always results in an exact 1 on the stack (as opposed to arbitrary nonzero value). Impossible for V. Implied by K</li>
</ul>

There are also four more properties that let us reason about nonmalleability:<ul>
<li><b>e</b> "expr": A unique way to dissatisfy this expression exists which cannot be modified into another dissatisfaction by an attacker. Conflicts with "f". Implies "d". Impossible for V.</li>
<li><b>f</b> "forced": There is no way to dissatisfy the expression, either under honest or malicious input. Conflicts with "d" and "e". Implied by V.</li>
<li><b>s</b> "safe": Satisfying this expression requires at least one signature. This means a dissatisfaction cannot be converted into a satisfaction for this expression. Implied by K.</li>
<li><b>m</b> "nonmalleable": For every way the condition can be met, a unique satisfaction exists which cannot be modified into another satisfaction by an attacker. Implied by Z.</li>
</ul>

<h3>Legend</h3>

<table border="1">
<tr>
  <th>Semantics</th>
  <th>Node</th>
  <th>Script</th>
  <th>nsat</th>
  <th>sat (X,Y)</th>
  <th>sat Z</th>
  <th>Types</th>
  <th>Req.</th>
  <th>Corr. prop.</th>
  <th>Mall. prop.</th>
</tr>
<tr>
  <td rowspan="2">check(key)</td>
  <td>pk(key)</td>
  <td>key</td>
  <td>0</td>
  <td>sig</td>
  <td>-</td>
  <td>K</td>
  <td></td>
  <td>o, n, u, d</td>
  <td>e, m, s</td>
</tr>
<tr>
  <td>pk_h(keyhash)</td>
  <td>DUP HASH160 keyhash EQUALVERFIFY</td>
  <td>0 key</td>
  <td>sig key</td>
  <td>-</td>
  <td>K</td>
  <td></td>
  <td>n, u, d</td>
  <td>e, m, s</td>
</tr>
<tr>
  <td>nSequence &ge; n (and compatible)</td>
  <td>older(n)</td>
  <td>n CHECKSEQUENCEVERIFY</td>
  <td>-</td>
  <td>[]</td>
  <td>-</td>
  <td>B</td>
  <td>n &ge; 1</td>
  <td>z</td>
  <td>f, m</td>
</tr>
<tr>
  <td>nLockTime &ge; n (and compaitlbe)</td>
  <td>after(n)</td>
  <td>n CHECKLOCKTIMEVERIFY</td>
  <td>-</td>
  <td>[]</td>
  <td>-</td>
  <td>B</td>
  <td>2<sup>31</sup> > n &ge; 1</td>
  <td>z</td>
  <td>f, m</td>
</tr>
<tr>
  <td>len(x) = 32 and SHA256(x) = h</td>
  <td>sha256(h)</td>
  <td>SIZE 32 EQUALVERIFY SHA256 h EQUAL</td>
  <td>000...</td>
  <td>x</td>
  <td>-</td>
  <td>B</td>
  <td></td>
  <td>o, n, u, d</td>
  <td>m</td>
</tr>
<tr>
  <td>len(x) = 32 and HASH256(x) = h</td>
  <td>hash256(h)</td>
  <td>SIZE 32 EQUALVERIFY HASH256 h EQUAL</td>
  <td>000...</td>
  <td>x</td>
  <td>-</td>
  <td>B</td>
  <td></td>
  <td>o, n, u, d</td>
  <td>m</td>
</tr>
<tr>
  <td>len(x) = 32 and RIPEMD160(x) = h</td>
  <td>ripemd160(h)</td>
  <td>SIZE 32 EQUALVERIFY RIPEMD160 h EQUAL</td>
  <td>000...</td>
  <td>x</td>
  <td>-</td>
  <td>B</td>
  <td></td>
  <td>o, n, u, d</td>
  <td>m</td>
</tr>
<tr>
  <td>len(x) = 32 and HASH160(x) = h</td>
  <td>hash160(h)</td>
  <td>SIZE 32 EQUALVERIFY HASH160 h EQUAL</td>
  <td>000...</td>
  <td>x</td>
  <td>-</td>
  <td>B</td>
  <td></td>
  <td>o, n, u, d</td>
  <td>m</td>
</tr>
<tr>
  <td rowspan="3">X and Y</td>
  <td>and_v(X,Y)</td>
  <td>[X] [Y]</td>
  <td>-</td>
  <td>sat<sub>Y</sub> sat<sub>X</sub></td>
  <td>-</td>
  <td>B=V<sub>X</sub>B<sub>Y</sub><br />K=V<sub>X</sub>K<sub>Y</sub><br />V=V<sub>X</sub>V<sub>Y</sub></td>
  <td></td>
  <td>
      u=u<sub>Y</sub><br />
      n=n<sub>X</sub>+z<sub>X</sub>n<sub>Y</sub><br />
      z=z<sub>X</sub>z<sub>Y</sub><br />
      o=z<sub>X</sub>o<sub>Y</sub>+o<sub>X</sub>z<sub>Y</sub>
  </td>
  <td>
      f=f<sub>X</sub>f<sub>Y</sub>[=f<sub>Y</sub>]<br />
      m=m<sub>X</sub>m<sub>Y</sub><br />
      s=s<sub>X</sub>+s<sub>Y</sub>
  </td>
</tr>
<tr>
  <td>and_b(X,Y)</td>
  <td>[X] [Y] BOOLAND</td>
  <td>nsat<sub>Y</sub> nsat<sub>X</sub></td>
  <td>sat<sub>Y</sub> sat<sub>X</sub></td>
  <td>-</td>
  <td>B=B<sub>X</sub>W<sub>Y</sub></td>
  <td></td>
  <td>
      z=z<sub>X</sub>z<sub>Y</sub><br />
      o=z<sub>X</sub>o<sub>Y</sub>+o<sub>X</sub>z<sub>Y</sub><br />
      n=n<sub>X</sub>+z<sub>X</sub>n<sub>Y</sub><br />
      d=d<sub>X</sub>d<sub>Y</sub><br />
      u
  </td>
  <td>
      f=f<sub>X</sub>f<sub>Y</sub><br />
      e=e<sub>X</sub>e<sub>Y</sub>s<sub>X</sub>s<sub>Y</sub><br />
      m=m<sub>X</sub>m<sub>Y</sub><br />
      s=s<sub>X</sub>+s<sub>Y</sub>
  </td>
</tr>
<tr>
  <td>and_n(X,Y)</td>
  <td>[X] NOTIF 0 ELSE [Y] ENDIF (=andor(X,Y,0))</td>
  <td>nsat<sub>X</sub></td>
  <td>sat<sub>Y</sub> sat<sub>X</sub></td>
  <td>-</td>
  <td>B=B<sub>X</sub>B<sub>Y</sub></td>
  <td>d<sub>X</sub>u<sub>X</sub></td>
  <td>
      z=z<sub>X</sub>z<sub>Y</sub><br />
      o=o<sub>X</sub>z<sub>Y</sub><br />
      u=u<sub>Y</sub><br />
      d=d<sub>X</sub>[=1]
  </td>
  <td>
      f=f<sub>Y</sub>f<sub>X</sub>[=0]<br />
      e=e<sub>X</sub>(s<sub>X</sub>+f<sub>Y</sub>)<br />
      m=m<sub>X</sub>m<sub>Y</sub>e<sub>X</sub><br />
      s=s<sub>X</sub>+s<sub>Y</sub>
  </td>
</tr>
<tr>
  <td rowspan="4">X or Z</td>
  <td>or_b(X,Z)</td>
  <td>[X] [Z] BOOLOR</td>
  <td>nsat<sub>Z</sub> nsat<sub>X</sub></td>
  <td>nsat<sub>Z</sub> sat<sub>X</sub></td>
  <td>sat<sub>Z</sub> nsat<sub>X</sub></td>
  <td>B=B<sub>X</sub>W<sub>Z</sub></td>
  <td>d<sub>X</sub>d<sub>Z</sub></td>
  <td>
      z=z<sub>X</sub>z<sub>Z</sub><br />
      o=z<sub>X</sub>o<sub>Z</sub>+o<sub>X</sub>z<sub>Z</sub><br />
      d=d<sub>X</sub>d<sub>Z</sub>[=1]<br />
      u
  </td>
  <td>
      f=f<sub>X</sub>+f<sub>Z</sub>[=0]<br />
      e=e<sub>X</sub>e<sub>Z</sub><br />
      m=m<sub>X</sub>m<sub>Z</sub>e<sub>X</sub>e<sub>Z</sub>(s<sub>X</sub>+s<sub>Z</sub>)<br />
      s=s<sub>X</sub>s<sub>Z</sub>
  </td>
</tr>
<tr>
  <td>or_d(X,Z)</td>
  <td>[X] IFDUP NOTIF [Z] ENDIF</td>
  <td>nsat<sub>Z</sub> nsat<sub>X</sub></td>
  <td>sat<sub>X</sub></td>
  <td>sat<sub>Z</sub> nsat<sub>X</sub></td>
  <td>B=B<sub>X</sub>B<sub>Z</sub></td>
  <td>d<sub>X</sub>u<sub>X</sub></td>
  <td>
      z=z<sub>X</sub>z<sub>Z</sub><br />
      o=o<sub>X</sub>z<sub>Z</sub><br />
      u=u<sub>X</sub>(f<sub>X</sub>+u<sub>Z</sub>)[=u<sub>Z</sub>]<br />
      d=d<sub>X</sub>d<sub>Z</sub>[=d<sub>Z</sub>]
  </td>
  <td>
      f=f<sub>X</sub>+f<sub>Z</sub>[=f<sub>Z</sub>]<br />
      e=e<sub>X</sub>e<sub>Z</sub><br />
      m=m<sub>X</sub>m<sub>Z</sub>e<sub>X</sub>(s<sub>X</sub>+s<sub>Z</sub>)<br />
      s=s<sub>X</sub>s<sub>Z</sub>
  </td>
</tr>
<tr>
  <td>or_c(X,Z)</td>
  <td>[X] NOTIF [Z] ENDIF</td>
  <td>-</td>
  <td>sat<sub>X</sub></td>
  <td>sat<sub>Z</sub> nsat<sub>X</sub></td>
  <td>V=B<sub>X</sub>V<sub>Z</sub></td>
  <td>d<sub>X</sub>u<sub>X</sub></td>
  <td>
      z=z<sub>X</sub>z<sub>Z</sub><br />
      o=o<sub>X</sub>z<sub>Z</sub>
  </td>
  <td>
      f=f<sub>X</sub>+f<sub>Z</sub>[=1]<br />
      m=m<sub>X</sub>m<sub>Z</sub>e<sub>X</sub>(s<sub>X</sub>+s<sub>Z</sub>)<br />
      s=s<sub>X</sub>s<sub>Z</sub>
  </td>
</tr>
<tr>
  <td>or_i(X,Z)</td>
  <td>IF [X] ELSE [Z] ENDIF</td>
  <td>nsat<sub>X</sub> 1<br />nsat<sub>Z</sub> 0</td>
  <td>sat<sub>X</sub> 1</td>
  <td>sat<sub>Z</sub> 0</td>
  <td>V=V<sub>X</sub>V<sub>Z</sub><br />B=B<sub>X</sub>B<sub>Z</sub><br />K=K<sub>X</sub>K<sub>Z</sub></td>
  <td></td>
  <td>
      o=z<sub>X</sub>z<sub>Z</sub><br />
      u=u<sub>X</sub>u<sub>Z</sub><br />
      d=d<sub>X</sub>+d<sub>Z</sub>
  </td>
  <td>
      f=f<sub>X</sub>f<sub>Z</sub><br />
      e=e<sub>X</sub>f<sub>Z</sub>+e<sub>Z</sub>f<sub>X</sub><br />
      m=m<sub>X</sub>m<sub>Z</sub>(s<sub>X</sub>+s<sub>Z</sub>)<br />
      s=s<sub>X</sub>s<sub>Z</sub>
  </td>
</tr>
<tr>
  <td>(X and Y) or Z</td>
  <td>andor(X,Y,Z)</td>
  <td>[X] NOTIF [Z] ELSE [Y] ENDIF</td>
  <td>nsat<sub>Z</sub> nsat<sub>X</sub></td>
  <td>sat<sub>Y</sub> sat<sub>X</sub></td>
  <td>sat<sub>Z</sub> nsat<sub>X</sub></td>
  <td>B=B<sub>X</sub>B<sub>Y</sub>B<sub>Z</sub><br />K=B<sub>X</sub>K<sub>Y</sub>K<sub>Z</sub><br />V=B<sub>X</sub>V<sub>Y</sub>V<sub>Z</sub></td>
  <td>d<sub>X</sub>u<sub>X</sub></td>
  <td>
      z=z<sub>X</sub>z<sub>Y</sub>z<sub>Z</sub><br />
      o=z<sub>X</sub>o<sub>Y</sub>o<sub>Z</sub>+o<sub>X</sub>z<sub>Y</sub>z<sub>Z</sub><br />
      u=u<sub>Y</sub>u<sub>Z</sub><br />
      d=d<sub>X</sub>d<sub>Z</sub>[=d<sub>Z</sub>]
  </td>
  <td>
      f=f<sub>Y</sub>(f<sub>X</sub>+f<sub>Z</sub>)[=f<sub>Y</sub>f<sub>Z</sub>]<br />
      e=e<sub>X</sub>e<sub>Z</sub>(s<sub>X</sub>+f<sub>Y</sub>)<br />
      m=m<sub>X</sub>m<sub>Y</sub>m<sub>Z</sub>e<sub>X</sub>(s<sub>X</sub>+s<sub>Y</sub>+s<sub>Z</sub>)<br />
      s=s<sub>Z</sub>(s<sub>X</sub>+s<sub>Y</sub>)
  </td>
</tr>
<tr>
  <td>X<sub>1</sub> + ... + X<sub>n</sub> = k</td>
  <td>thresh(k,...)</td>
  <td>[X<sub>1</sub>] ([X<sub>i</sub> ADD)*(n-1) k EQUAL</td>
  <td>nsat...</td>
  <td>(sat|nsat)...</td>
  <td>-</td>
  <td>B=X<sub>1</sub> is B<br />others are W</td>
  <td>n > k > 1<br />all are d and u</td>
  <td>
      z=all are z<br />
      o=all are z, except one is o<br />
      d<br />
      u
  </td>
  <td>
      e=all are e and s<br />
      m=all are e and m, &ge;(n-k) are s<br />
      s=&ge;(n-k+1) are s
  </td>
</tr>
<tr>
  <td>check(key_1) + ... = k</td>
  <td>thresh_m(k,...)</td>
  <td>k key_1 ... key_n n CHECKMULTISIG</td>
  <td>0 0 ... 0</td>
  <td>0 sig...</td>
  <td>-</td>
  <td>B</td>
  <td>n &ge; k &ge; 1</td>
  <td>n, u, d</td>
  <td>e, m, s</td>
</tr>
<tr>
  <td rowspan="10">X</td>
  <td>a:X</td>
  <td>TOALTSTACK [X] FROMALTSTACK</td>
  <td>nsat<sub>X</sub></td>
  <td>sat<sub>X</sub></td>
  <td>-</td>
  <td>W=B<sub>X</sub></td>
  <td></td>
  <td>u=u<sub>X</sub>, d=d<sub>X</sub></td>
  <td>f=f<sub>X</sub>, e=e<sub>X</sub>, m=m<sub>X</sub>, s=s<sub>X</sub></td>
</tr>
<tr>
  <td>s:X</td>
  <td>SWAP [X]</td>
  <td>nsat<sub>X</sub></td>
  <td>sat<sub>X</sub></td>
  <td>o<sub>X</sub></td>
  <td>W=B<sub>X</sub></td>
  <td></td>
  <td>u=u<sub>x</sub>, d=d<sub>X</sub></td>
  <td>f=f<sub>X</sub>, e=e<sub>X</sub>, m=m<sub>X</sub>, s=s<sub>X</sub></td>
</tr>
<tr>
  <td>c:X</td>
  <td>[X] CHECKSIG</td>
  <td>nsat<sub>X</sub></td>
  <td>sat<sub>X</sub></td>
  <td>-</td>
  <td>B=K<sub>X</sub></td>
  <td></td>
  <td>o=o<sub>X</sub>, n=n<sub>X</sub>, u, d=d<sub>X</sub></td>
  <td>e=e<sub>X</sub>, m=m<sub>X</sub>, s=s<sub>X</sub>[=1]</td>
</tr>
<tr>
  <td>t:X</td>
  <td>[X] 1 (=and_v(X,1))</td>
  <td>-</td>
  <td>sat<sub>X</sub></td>
  <td>-</td>
  <td>B=V<sub>X</sub></td>
  <td></td>
  <td>u, n=n<sub>X</sub>, z=z<sub>X</sub>, o=o<sub>X</sub></td>
  <td>f, m=m<sub>X</sub>, s=s<sub>X</sub></td>
<tr>
  <td>d:X</td>
  <td>DUP IF [X] ENDIF</td>
  <td>0</td>
  <td>sat<sub>X</sub> 1</td>
  <td>-</td>
  <td>B=V<sub>X</sub></td>
  <td>z<sub>X</sub></td>
  <td>o=z<sub>X</sub>, n, u, d</td>
  <td>e=f<sub>X</sub>, m=m<sub>X</sub>, s=s<sub>X</sub></td>
</tr>
<tr>
  <td>v:X</td>
  <td>[X] VERIFY</td>
  <td>-</td>
  <td>sat<sub>X</sub></td>
  <td>-</td>
  <td>V=B<sub>X</sub></td>
  <td></td>
  <td>z=z<sub>X</sub>, o=o<sub>X</sub>, n=n<sub>X</sub></td>
  <td>f, m=m<sub>X</sub>, s=s<sub>X</sub></td>
</tr>
<tr>
  <td>j:X</td>
  <td>SIZE 0NOTEQUAL IF [X] ENDIF</td>
  <td>0</td>
  <td>sat<sub>X</sub></td>
  <td>-</td>
  <td>B=B<sub>X</sub></td>
  <td>n<sub>X</sub></td>
  <td>o=o<sub>X</sub>, n, u=u<sub>X</sub>, d</td>
  <td>e=f<sub>X</sub>, m=m<sub>X</sub>, s=s<sub>X</sub></td>
</tr>
<tr>
  <td>n:X</td>
  <td>[X] 0NOTEQUAL</td>
  <td>nsat<sub>X</sub></td>
  <td>sat<sub>X</sub></td>
  <td>-</td>
  <td>B=B<sub>X</sub></td>
  <td></td>
  <td>z=z<sub>X</sub>, o=o<sub>X</sub>, n=n<sub>X</sub>, u, d=d<sub>X</sub></td>
  <td>f=f<sub>X</sub>, e=e<sub>X</sub>, m=m<sub>X</sub>, s=s<sub>X</sub></td>
</tr>
<tr>
  <td>l:X</td>
  <td>IF 0 ELSE [X] ENDIF (=or_i(0,X))</td>
  <td>1</td>
  <td>sat<sub>X</sub> 0</td>
  <td>-</td>
  <td>B=B<sub>X</sub></td>
  <td></td>
  <td>o=z<sub>X</sub>, u=u<sub>X</sub>, d</td>
  <td>e=f<sub>X</sub>, m=m<sub>X</sub>, s=s<sub>X</sub></td>
</tr>
<tr>
  <td>u:X</td>
  <td>IF [X] ELSE 0 ENDIF (=or_i(X,0))</td>
  <td>0</td>
  <td>sat<sub>X</sub> 1</td>
  <td>-</td>
  <td>B=B<sub>X</sub></td>
  <td></td>
  <td>o=z<sub>X</sub>, u=u<sub>X</sub>, d</td>
  <td>e=f<sub>X</sub>, m=m<sub>X</sub>, s=s<sub>X</sub></td>
</tr>
<tr>
  <td>true</td>
  <td>1</td>
  <td>1</td>
  <td>-</td>
  <td>[]</td>
  <td>-</td>
  <td>B</td>
  <td></td>
  <td>z, u</td>
  <td>f, m</td>
</tr>
<tr>
  <td>false</td>
  <td>0</td>
  <td>0</td>
  <td>[]</td>
  <td>-</td>
  <td>-</td>
  <td>B</td>
  <td></td>
  <td>z, u, d</td>
  <td>e, m, s</td>
</tr>
</table>

</div>
</div>
</div>

</body>
</html>
